import math

class Calculator:
    def add(self, a, b):
        return a + b

    def subtract(self, a, b):
        return a - b

    def multiply(self, a, b):
        return a * b

    def divide(self, a, b):
        # ‚ùå No check for division by zero
        return a / b

    def power(self, a, b):
        return math.pow(a, b)

    def square_root(self, a):
        # ‚ùå No check for negative input
        return math.sqrt(a)


def main():
    calc = Calculator()

    print("=== Buggy Calculator ===")
    print("Operations: +, -, *, /, ^, sqrt, exit")

    while True:
        op = input("\nEnter operation: ")

        if op == "exit":
            print("Bye!")
            break

        # ‚ùå No validation ‚Äî assumes user enters numbers correctly
        num1 = float(input("Enter first number: "))

        # ‚ùå 'sqrt' uses only one argument, but we're still asking for two
        if op != "sqrt":
            num2 = float(input("Enter second number: "))

        # ‚ùå No error handling ‚Äî can crash anytime
        if op == "+":
            print("Result:", calc.add(num1, num2))
        elif op == "-":
            print("Result:", calc.subtract(num1, num2))
        elif op == "*":
            print("Result:", calc.multiply(num1, num2))
        elif op == "/":
            print("Result:", calc.divide(num1, num2))  # will crash on divide by zero
        elif op == "^":
            print("Result:", calc.power(num1, num2))
        elif op == "sqrt":
            print("Result:", calc.square_root(num1))  # will crash on negative numbers
        else:
            print("Invalid operation!")  # ‚ùå won't stop invalid math logic


if __name__ == "__main__":
    main()




------------------------------------------------------------------------------------------------------------------------------------


Time Zone converter

                      -:Correct code:-

from datetime import datetime
import pytz

def show_time_in_timezone(timezone_name):
    try:
        timezone = pytz.timezone(timezone_name)
    except pytz.UnknownTimeZoneError:
        print(f"‚ùå Invalid timezone: {timezone_name}")
        return

    local_time = datetime.now(timezone)
    print(f"üïì Current time in {timezone_name}: {local_time.strftime('%Y-%m-%d %H:%M:%S')}")

def main():
    print("==== Time Zone Converter ====")
    print("Example zones: Asia/Kolkata, America/New_York, Europe/London, Australia/Sydney")
    print("Type 'list' to see all available zones")
    print("Type 'exit' to quit\n")

    while True:
        zone = input("Enter timezone: ").strip()

        if zone.lower() == "exit":
            print("Goodbye!")
            break
        elif zone.lower() == "list":
            print("Some common zones:")
            print("Asia/Kolkata, Asia/Dubai, Europe/London, America/New_York, America/Los_Angeles, Australia/Sydney, Africa/Johannesburg")
            continue

        show_time_in_timezone(zone)

if __name__ == "__main__":
    main()



                      -:Faulty code:-

import datetime,pytz # ‚ùå multiple imports on one line (bad practice)

def t(z):  # ‚ùå non-descriptive function name
 tz=pytz.timezone(z)   # ‚ùå inconsistent indentation, unclear variable name
 x=datetime.datetime.now(tz) # ‚ùå unspaced operators
 print("time in",z,"is",x) # ‚ùå improper print formatting

def main():     # ‚ùå lowercase function name for entry point is ok, but formatting is off
 print("enter tz name OR quit") # ‚ùå unclear instructions
 while True:
  i=input(">>> ") # ‚ùå one-letter variable names, bad naming
  if i=="quit":break   # ‚ùå inline control flow, no spacing
  elif len(i)==0:print("nothing entered") # ‚ùå bad structure, no else block
  else:
   try:t(i) # ‚ùå bad indentation + inline try block
   except:print("something wrong lol") # ‚ùå catching all exceptions with no specificity

main() # ‚ùå no `if __name__ == "__main__":` guard



-------------------------------------------------------------------------------------------------------------------------------------

                                       --:Library management code:--


from datetime import datetime

class Book:
    """Represents a single book in the library."""
    def __init__(self, book_id, title, author, copies=1):
        self.book_id = book_id
        self.title = title
        self.author = author
        self.copies = copies
        self.borrowed_by = []  # list of member IDs

    def __str__(self):
        return f"[{self.book_id}] {self.title} by {self.author} (Available: {self.copies})"


class Member:
    """Represents a library member."""
    def __init__(self, member_id, name):
        self.member_id = member_id
        self.name = name
        self.borrowed_books = []  # list of book IDs

    def __str__(self):
        return f"{self.member_id}: {self.name}"


class Library:
    """Main Library system managing books and members."""
    def __init__(self):
        self.books = {}   # {book_id: Book}
        self.members = {} # {member_id: Member}

    def add_book(self, book_id, title, author, copies=1):
        if book_id in self.books:
            self.books[book_id].copies += copies
            print(f"‚úÖ Added {copies} more copies of '{title}'.")
        else:
            self.books[book_id] = Book(book_id, title, author, copies)
            print(f"üìò Book '{title}' added successfully.")

    def add_member(self, member_id, name):
        if member_id in self.members:
            print(f"‚ö†Ô∏è Member ID {member_id} already exists.")
        else:
            self.members[member_id] = Member(member_id, name)
            print(f"üë§ Member '{name}' added successfully.")

    def borrow_book(self, member_id, book_id):
        if member_id not in self.members:
            print("‚ùå Member not found.")
            return
        if book_id not in self.books:
            print("‚ùå Book not found.")
            return

        member = self.members[member_id]
        book = self.books[book_id]

        if book.copies == 0:
            print(f"‚ùå '{book.title}' is currently not available.")
            return

        book.copies -= 1
        book.borrowed_by.append(member_id)
        member.borrowed_books.append(book_id)
        print(f"üìö '{book.title}' borrowed by {member.name} on {datetime.now().strftime('%Y-%m-%d')}.")

    def return_book(self, member_id, book_id):
        if member_id not in self.members or book_id not in self.books:
            print("‚ùå Invalid member or book ID.")
            return

        member = self.members[member_id]
        book = self.books[book_id]

        if book_id not in member.borrowed_books:
            print(f"‚ö†Ô∏è {member.name} didn‚Äôt borrow '{book.title}'.")
            return

        member.borrowed_books.remove(book_id)
        book.borrowed_by.remove(member_id)
        book.copies += 1
        print(f"‚úÖ '{book.title}' returned by {member.name}.")

    def list_books(self):
        if not self.books:
            print("üìÇ No books in inventory.")
            return
        print("\nüìö Library Inventory:")
        for book in self.books.values():
            print(book)

    def list_members(self):
        if not self.members:
            print("üë• No members registered.")
            return
        print("\nüë• Library Members:")
        for member in self.members.values():
            print(member)


# --- Example Usage ---
if __name__ == "__main__":
    lib = Library()

    # Adding books and members
    lib.add_book(1, "Harry Potter", "J.K. Rowling", 3)
    lib.add_book(2, "1984", "George Orwell", 2)
    lib.add_member(101, "Alice")
    lib.add_member(102, "Bob")

    # Borrowing and returning
    lib.borrow_book(101, 1)
    lib.borrow_book(102, 2)
    lib.return_book(101, 1)

    # Listing
    lib.list_books()
    lib.list_members()



                                             --:Faulty code:--

# ‚ùå No docstrings, poor formatting, inconsistent naming

class book:    # ‚ùå class name not capitalized
 def __init__(self,id,title,author,copies=1): # ‚ùå inconsistent indentation, no spaces around '='
  self.id=id; self.title=title; self.author=author; self.copies=copies; self.borrowed=[] # ‚ùå multiple statements on one line

 def __str__(self): return f"{self.title}-{self.author}-{self.copies}" # ‚ùå one-liner methods


class member:  # ‚ùå lowercase class name
 def __init__(self,mid,name): self.mid=mid; self.name=name; self.borrowed=[]


class lib:  # ‚ùå meaningless class name, bad naming
 def __init__(self): self.books={}; self.members={}

 def addBook(self,id,title,author,copies=1):   # ‚ùå inconsistent camelCase naming
  if id in self.books: self.books[id].copies+=copies; print("copies added")
  else:self.books[id]=book(id,title,author,copies); print("book added")  # ‚ùå inconsistent indentation

 def addMember(self,mid,name):
  if mid in self.members: print("exists")
  else:self.members[mid]=member(mid,name); print("member added")

 def borrow(self,mid,bid):
  b=self.books[bid] # ‚ùå no check if ID exists ‚Üí KeyError
  m=self.members[mid] # ‚ùå may also raise KeyError if mid invalid
  if b.copies<=0: print("not available"); return
  b.copies-=1; b.borrowed.append(mid); m.borrowed.append(bid); print(m.name,"borrowed",b.title) # ‚ùå long line, inline logic

 def returnBook(self,mid,bid):
  b=self.books[bid]; m=self.members[mid]
  if bid not in m.borrowed: print("not borrowed by user");return
  m.borrowed.remove(bid);b.borrowed.remove(mid);b.copies+=1;print("returned")

 def list(self):  # ‚ùå method name collides with built-in `list`
  for k,v in self.books.items(): print(v.id,v.title,v.copies) # ‚ùå missing space after commas


# ‚ùå No __main__ guard, immediate execution
L=lib()
L.addBook(1,"Python Crash Course","Eric",2)
L.addBook(2,"1984","George Orwell",1)
L.addMember(1,"Aman")
L.addMember(2,"Bob")

L.borrow(1,1)
L.borrow(2,3)   # ‚ùå Invalid book ID ‚Äî will crash (KeyError)
L.returnBook(1,2) # ‚ùå Return without borrow ‚Äî inconsistent state

L.list()



